import { supabase, Passage, UserAttempt } from '../lib/supabase';

export interface Question {
  id: string;
  category: 'ANG' | 'CG' | 'LOG';
  sub_category: string;
  question_text: string;
  answer1: string;
  answer2: string;
  answer3: string;
  answer4: string;
  correct: 'A' | 'B' | 'C' | 'D';
  difficulty: 'easy' | 'medium' | 'hard';
  exam_type?: 'CM' | 'CMS' | 'CS';
  passage_id?: string; // Reference to passage if question is based on a text
  created_at: string;
}

export interface QuestionWithPassage {
  question: Question;
  passage?: Passage;
}

export class QuestionService {
  static async getQuestionsByCategory(
    category: 'ANG' | 'CG' | 'LOG',
    subCategory?: string,
    limit: number = 10
  ): Promise<Question[]> {
    try {
      let query = supabase
        .from('questions')
        .select('*')
        .eq('category', category);

      if (subCategory) {
        query = query.eq('sub_category', subCategory);
      }

      const { data, error } = await query
        .limit(limit)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching questions:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getQuestionsByCategory:', error);
      return [];
    }
  }

  static async getRandomQuestions(
    category: 'ANG' | 'CG' | 'LOG',
    limit: number = 10,
    subCategory?: string,
    testNumber?: number,
    examType?: 'CM' | 'CMS' | 'CS'
  ): Promise<Question[]> {
    try {
      let query = supabase
        .from('questions')
        .select('*')
        .eq('category', category);

      if (subCategory) {
        query = query.eq('sub_category', subCategory);
      }

      // Add exam_type filter if provided
      if (examType) {
        query = query.eq('exam_type', examType);
      }

      const { data, error } = await query
        .limit(limit * 3) // Get more questions to ensure we have enough for randomization
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching random questions:', error);
        return [];
      }

      const questions = data || [];
      
      // Create a proper seed for randomization
      let seed: number;
      
      if (testNumber !== undefined) {
        // For practice tests: use test number to ensure different questions per test
        seed = testNumber * 1000 + category.charCodeAt(0) * 100 + (category.charCodeAt(1) || 0) * 10 + (category.charCodeAt(2) || 0);
        console.log(`üéØ Practice test mode: Using test number ${testNumber} as seed for ${category} (seed: ${seed})`);
      } else {
        // For daily quizzes: use date to ensure questions change daily
        const today = new Date();
        const dateSeed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
        seed = dateSeed + category.charCodeAt(0) * 100 + (category.charCodeAt(1) || 0) * 10 + (category.charCodeAt(2) || 0);
        console.log(`üìÖ Daily quiz mode: Using date ${today.toDateString()} (${dateSeed}) as seed for ${category} (seed: ${seed})`);
      }
      
      // Fisher-Yates shuffle with seeded randomization
      const shuffled = [...questions];
      for (let i = shuffled.length - 1; i > 0; i--) {
        // Generate a pseudo-random number based on the seed
        seed = (seed * 9301 + 49297) % 233280;
        const j = Math.floor((seed / 233280) * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      
      // Take the first 'limit' questions
      const result = shuffled.slice(0, limit);
      
      console.log(`‚úÖ Fetched ${result.length} questions for ${category} with seed ${seed}`);
      return result;
    } catch (error) {
      console.error('‚ùå Error in getRandomQuestions:', error);
      return [];
    }
  }

  static async getQuestionsByTestType(
    category: 'ANG' | 'CG' | 'LOG',
    testType: 'quiz_series' | 'practice_test' | 'examen_blanc',
    limit: number = 10
  ): Promise<Question[]> {
    try {
      let query = supabase
        .from('questions')
        .select('*')
        .eq('category', category)
        .eq('test_type', testType);

      const { data, error } = await query
        .limit(limit)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching questions by test type:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getQuestionsByTestType:', error);
      return [];
    }
  }

  static async getQuestionsByDifficulty(
    category: 'ANG' | 'CG' | 'LOG',
    difficulty: 'easy' | 'medium' | 'hard',
    limit: number = 10
  ): Promise<Question[]> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select('*')
        .eq('category', category)
        .eq('difficulty', difficulty)
        .limit(limit)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching questions by difficulty:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in getQuestionsByDifficulty:', error);
      return [];
    }
  }

  static async getRandomQuestionsFromPool(
    category: 'ANG' | 'CG' | 'LOG',
    pool: string,
    limit: number = 10
  ): Promise<Question[]> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select('*')
        .eq('category', category)
        .eq('question_pool', pool)
        .limit(limit * 2) // Get more questions for randomization
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching questions from pool:', error);
        return [];
      }

      const questions = data || [];
      
      // Simple shuffle
      const shuffled = questions.sort(() => Math.random() - 0.5);
      
      return shuffled.slice(0, limit);
    } catch (error) {
      console.error('‚ùå Error in getRandomQuestionsFromPool:', error);
      return [];
    }
  }

  static async getQuestionById(id: string): Promise<Question | null> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        console.error('Error fetching question by ID:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in getQuestionById:', error);
      return null;
    }
  }

  static async getQuestionsWithPassages(
    category: 'ANG' | 'CG' | 'LOG',
    limit: number = 10
  ): Promise<QuestionWithPassage[]> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select(`
          *,
          passages (
            id,
            title,
            content,
            category
          )
        `)
        .eq('category', category)
        .not('passage_id', 'is', null)
        .limit(limit)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching questions with passages:', error);
        return [];
      }

      return (data || []).map(item => ({
        question: {
          id: item.id,
          category: item.category,
          sub_category: item.sub_category,
          question_text: item.question_text,
          answer1: item.answer1,
          answer2: item.answer2,
          answer3: item.answer3,
          answer4: item.answer4,
          correct: item.correct,
          difficulty: item.difficulty,
          exam_type: item.exam_type,
          passage_id: item.passage_id,
          created_at: item.created_at
        },
        passage: item.passages
      }));
    } catch (error) {
      console.error('Error in getQuestionsWithPassages:', error);
      return [];
    }
  }

  static async searchQuestions(
    category: 'ANG' | 'CG' | 'LOG',
    searchTerm: string,
    limit: number = 10
  ): Promise<Question[]> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select('*')
        .eq('category', category)
        .textSearch('question_text', searchTerm)
        .limit(limit)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error searching questions:', error);
        return [];
      }

      return data || [];
    } catch (error) {
      console.error('Error in searchQuestions:', error);
      return [];
    }
  }

  static async getQuestionStats(category: 'ANG' | 'CG' | 'LOG'): Promise<{
    total: number;
    byDifficulty: { easy: number; medium: number; hard: number };
    byTestType: { quiz_series: number; practice_test: number; examen_blanc: number };
  }> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select('difficulty, test_type')
        .eq('category', category);

      if (error) {
        console.error('Error fetching question stats:', error);
        return { total: 0, byDifficulty: { easy: 0, medium: 0, hard: 0 }, byTestType: { quiz_series: 0, practice_test: 0, examen_blanc: 0 } };
      }

      const questions = data || [];
      const total = questions.length;
      
      const byDifficulty = questions.reduce((acc, q) => {
        acc[q.difficulty as keyof typeof acc]++;
        return acc;
      }, { easy: 0, medium: 0, hard: 0 });
      
      const byTestType = questions.reduce((acc, q) => {
        if (q.test_type) {
          acc[q.test_type as keyof typeof acc]++;
        }
        return acc;
      }, { quiz_series: 0, practice_test: 0, examen_blanc: 0 });

      return { total, byDifficulty, byTestType };
    } catch (error) {
      console.error('Error in getQuestionStats:', error);
      return { total: 0, byDifficulty: { easy: 0, medium: 0, hard: 0 }, byTestType: { quiz_series: 0, practice_test: 0, examen_blanc: 0 } };
    }
  }

  static async createQuestion(question: Omit<Question, 'id' | 'created_at'>): Promise<Question | null> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .insert([question])
        .select()
        .single();

      if (error) {
        console.error('Error creating question:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in createQuestion:', error);
      return null;
    }
  }

  static async updateQuestion(id: string, updates: Partial<Question>): Promise<Question | null> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('Error updating question:', error);
        return null;
      }

      return data;
    } catch (error) {
      console.error('Error in updateQuestion:', error);
      return null;
    }
  }

  static async deleteQuestion(id: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('questions')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('Error deleting question:', error);
        return false;
      }

      return true;
    } catch (error) {
      console.error('Error in deleteQuestion:', error);
      return false;
    }
  }
}
